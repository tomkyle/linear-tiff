#!/usr/bin/env bash

# *******************************************************
#
#  linear-tiff
#
#  Author: Carsten Witt <tomkyle@posteo.de>
#  Homepage: <https://github.com/tomkyle/negatives-linear-tiff>
#
#  David Coffin's dcraw:
#  http://cybercom.net/~dcoffin/dcraw/
#  http://cybercom.net/~dcoffin/dcraw/dcraw.1.html
#
#  ImageMagick:
#  http://www.imagemagick.org/script/mogrify.php
#  http://www.imagemagick.org/script/convert.php
#
#  GNU Parallel:
#  https://www.gnu.org/software/parallel/
#
# *******************************************************


# Runtime Environment
set -o errexit
set -o nounset
set -o pipefail
# set -o xtrace


# Internal Field Separator
readonly DEFAULT_IFS="${IFS}"
readonly SAFER_IFS=$'\n\t'
IFS="${SAFER_IFS}"


# Check on Requirements
function require  {
    command -v "${1}" >/dev/null 2>&1 || e_error "$(printf "Program '%s' required, but it's not installed" "${1}")"
}


# Default Exit or SIGINT(2) handler
function trapCleanupTempDir() {
    tmp_dir_to_clean="${WORK_TMPDIR:-}"
    if [ -d "${tmp_dir_to_clean}" ]; then
        printf "\nRemove temporary directory %s ... " "${tmp_dir_to_clean}"
        rm -Rf "${tmp_dir_to_clean}" && e_success
    fi
    echo;
}
trap trapCleanupTempDir EXIT SIGINT



# --------------------------------------
# Filesystem basics
# --------------------------------------

# Filesystem basics
readonly SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
readonly SCRIPT_NAME=$(basename "${0}")

# Consistent package location
readonly HOMEBREW_OPT_DIR=$(brew --prefix "$(basename "${0}")")
# Hack for development purposes
# HOMEBREW_OPT_DIR=$SCRIPT_DIR

# Prepare (but not create) a new temp directory
readonly WORK_TMPDIR=$(mktemp -du "${TMPDIR:-/tmp/}$(basename 0).XXXXXXXXXXXX")  || { e_error "Failed to create temp directory name."; }

# Where to search
declare SEARCH_DIRECTORY='.'

# What to search
# The regex shown here must be suitable for regex find'ing: -iregex '.*\.(nef|raw|cr2)'
declare SEARCH_FILES_IREGEX='.*\.(nef|raw|cr2)'


# --------------------------------------
# Global settings:
# --------------------------------------

# Dcraw output
#
# Default extension of dcraw's TIFF output
declare DCRAW_DEFAULT_TIFF_EXTENSION="tiff"


# Clip highlights method
#
# -H 0 Clip all highlights to solid white (default).
# -H 5 as a compromise
declare -i DCRAW_HIGHLIGHTS_VALUE=5


# Bayer demosaicing algorithm dcraw should use
#
# -q 0  Use high-speed, low-quality bilinear interpolation.
# -q 1  Variable Number of Gradients (VNG) interpolation.
# -q 2  Patterned Pixel Grouping (PPG) interpolation.
# -q 3  Adaptive Homogeneity-Directed (AHD) interpolation.
# Leave blank when needed.
local -i DCRAW_BAYER_DEMOSAIC_VALUE=3


# dcraw's output colorspace
#
# 0   Raw color (unique to each camera)
# 1   sRGB D65 (default)
# 2   Adobe RGB (1998) D65
# 3   Wide Gamut RGB D65
# 4   Kodak ProPhoto RGB D65
# 5   XYZ
# 6   ACES
local -i DCRAW_COLORSPACE_VALUE=1


# Dcraw's image flipping
#
# Disable with "-t 0"
# Leave blank to flip automatically.
local DCRAW_FLIP_IMAGE="-t 0"


# Dcraw's White balance
#
# -w White balance according to camera settings
#    at the moment of the shot
local DCRAW_WHITE_BALANCE="-w"





# --------------------------------------
# User settings:
# These settings can be set with command line arguments.
# --------------------------------------


# List of possible script arguments (getopts)
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
readonly OPTIONS_LIST="ahdvf:o:r:"

# Verbous mode:
# Disabled per default; enable with -v flag
declare -i verbous_mode=0;

# Grayscale output image:
# Disabled per default (0)
# Set to 1 to enable or use -d flag
declare -i desaturate_colors=0

# Resize output image:
# Disabled per default (0)
# Use with -r <width>
# or set this value to any pixel width
declare -i resize_width=0

# Trigger extra-verbous debugging mode
# Disabled per default (0)
# Set to 1 to enable or use --debug option
declare -i debug_mode=0

# Mirror output image horizontally or vertically.
# Disabled per default ("")
# Use with "-f flip|flop|flipflop"
# or set value here.
declare flipflop_positive=""

# Where to store the output images.
# Default ist current work directory.
declare output_directory="${PWD}"


# --------------------------------------
# Miscellaneous
# --------------------------------------

# Formatting stuff
readonly C_WHITE='\033[1;37m'
readonly C_RED='\033[0;31m'
readonly C_GREEN='\033[0;32m'
readonly C_BLUE='\033[1;34m'
readonly C_GRAY='\033[1;30m'
readonly C_ORANGE=$(tput setaf 3)
readonly NC='\033[0m' # No Color

# Informative files
readonly LICENSE_FILE="LICENSE"
readonly USAGE_FILE="USAGE"
readonly CREDITS_FILE="CREDITS"


# --------------------------------------
# Output and formatting functions
# --------------------------------------


# Error message and error exit, redirecting stdout to stderr
function e_error {
    echo -e >&2 "${C_RED}Error: ${*}${NC}";
    exit 1;
}

function e_info {
  echo -e "${C_BLUE}${*}${NC}"
}

function e_warning {
  echo -e "${C_ORANGE}Warning: ${*}${NC}"
}

function e_success () {
  printf "${C_GREEN}âœ” %s${NC}" "${*-}"
  if [ $debug_mode -gt 0 ]; then
    echo -e ""
  fi
}

function e_result () {
  echo -e "${C_GREEN}${*}${NC}"
}

function e_verbous () {
  if [ $verbous_mode -gt 0 ]; then
    printf "${C_GRAY}%s${NC}" "${*}"
  fi
}

function e_debug () {
  if [ $debug_mode -gt 0 ]; then
    printf "${C_GRAY}%s${NC}" "${*}"
  fi
}

# --------------------------------------
# Create Todo file
# --------------------------------------
function createTodoFile {
  mkdir -p "${WORK_TMPDIR}"
  TODO_TXT="${WORK_TMPDIR}/rawfiles-todo.txt"
  touch "${TODO_TXT}"
  echo "${TODO_TXT}"
}




# --------------------------------------
# Count lines in file
#
# Usage:
#   countLinesInFile <file>
# --------------------------------------
function countLinesInFile {
    wc -l < "${1}" | sed -e 's/^[ \t]*//'
}

# --------------------------------------
# catFirstFound
#
# Outputs given file in first matching location.
#
# Usage:
#   catFirstFound <file>
#
# --------------------------------------
function catFirstFound {
    local file_to_cat="${1}"
    local lookup=("${HOMEBREW_OPT_DIR}" "${SCRIPT_DIR}")

    for dir in "${lookup[@]}"; do
        if [ -f "${dir}/${file_to_cat}" ]; then
            cat "${dir}/${file_to_cat}"
        fi;
    done
    echo;
}


# --------------------------------------
# findFiles
#
# Usage:
#   findFiles iregex dir
# --------------------------------------
function findFiles {
    local regex=${1}
    local directory=${2}
    find -E "${directory}" -maxdepth 1 -type f -iregex "${regex}"
}


# --------------------------------------
# displayHelp
# --------------------------------------
function displayHelp {
    catFirstFound "${USAGE_FILE}"
    catFirstFound "${CREDITS_FILE}"
    exit 1;
}


# --------------------------------------
# _require_argument()
#
# Usage:
#   _require_argument <option> <argument>
#
# If <argument> is blank or another option, print an error message
#
# This function is stolen from William Melody's bash-boilerplate
# <https://github.com/alphabetum/bash-boilerplate>
# --------------------------------------

_require_argument() {
    # Set local variables from arguments.
    #
    # NOTE: 'local' is a non-POSIX bash feature and keeps the variable local to
    # the block of code, as defined by curly braces. It's easiest to just think
    # of them as local to a function.
    local _option="${1:-}"
    local _argument="${2:-}"

    if [[ -z "${_argument}" ]] || [[ "${_argument}" =~ ^- ]]
    then
        e_error "$(printf "Option requires a argument: %s\n" "${_option}")"
    fi
}




# ======================================
#  runBatchMode
# ======================================

function runBatchMode {

    # ---------------------------------------
    # Requirements
    # ---------------------------------------

    # Homebrew requirements
    require parallel

    # System commands
    require getconf

    # Stores all function parameters for use with GNU Parallel
    local -r FUNC_ARGUMENTS=("${@}")

    # For statistic purposes
    local START_TIME=$SECONDS
    local -r CPUs=$(getconf _NPROCESSORS_ONLN)

    # ---------------------------------------
    # Find stuff to work on
    # ---------------------------------------
    local -r TODO_TXT=$(createTodoFile)
    findFiles "${SEARCH_FILES_IREGEX}" "${SEARCH_DIRECTORY}" > "${TODO_TXT}"
    local -r number_of_images=$(countLinesInFile "${TODO_TXT}")


    # ---------------------------------------
    # Start parallel processing
    # ---------------------------------------
    if [ $verbous_mode -gt 0 ]; then
        printf "Process these %s images:\n" "${number_of_images}"

        # When few images to be processed, cat command should be plenty
        [ $number_of_images -le 6 ] && cat_or_column="cat" || cat_or_column="column"

        printf "${C_GRAY}%s\n${NC}" "$(${cat_or_column} "${TODO_TXT}")"
        echo;
    fi

    if [ $debug_mode -gt 0 ]; then
      echo "This is what GNU Parallel does:"
      e_debug $(parallel --dry-run -a "${TODO_TXT}" "$0" "${FUNC_ARGUMENTS[@]}" "{}")
      echo;
      echo;
    fi

    parallel -a "${TODO_TXT}" "$0" "${FUNC_ARGUMENTS[@]}" "{}"


    # ---------------------------------------
    # Outro
    # ---------------------------------------

    # Some stats
    local -r ELAPSED_TIME=$((SECONDS - START_TIME))

    printf "Some stats:\n"
    printf "CPUs used:     %s\n"          "${CPUs}"
    printf "Elapsed time:  %smin %ssec\n" $((ELAPSED_TIME/60)) $((ELAPSED_TIME%60))
    printf "Done:          %s images\n"   "${number_of_images}"


}


# ======================================
#  convertRawPhotos
#
#  Usage: convertRawPhotos rawfile [rawfiles ...]
# ======================================

function convertRawPhotos {

    # --------------------------------------
    # Requirements
    # --------------------------------------

    # Homebrew dependencies
    require dcraw
    require mogrify
    require color-profiles

    # System commands
    require getconf
    require brew
    require dirname
    require basename

    # Files to work on.
    local -r INPUT_FILES=("${@}")






    # --------------------------------------
    # Default ICC profile.
    # See DCRAW_COLORSPACE_VALUE
    # --------------------------------------
    local ICC_PROFILE_PATH=$(color-profiles srgb-linear )


    # ---------------------------------------
    # Build dcraw parameters
    # ---------------------------------------
    local dcraw_options=""

    # Add white balance setting
    if [ ! -z "${DCRAW_WHITE_BALANCE}" ]; then
        dcraw_options+=" ${DCRAW_WHITE_BALANCE}"
    fi;

    # Add flip image setting
    if [ ! -z "${DCRAW_FLIP_IMAGE}" ]; then
        dcraw_options+=" ${DCRAW_FLIP_IMAGE}"
    fi;

    # How to handle highlights
    if [ $DCRAW_HIGHLIGHTS_VALUE -gt 0 ]; then
        dcraw_options+=" -H ${DCRAW_HIGHLIGHTS_VALUE}"
    fi;

    # Add demosaicing algorithm number
    dcraw_options+=" -q ${DCRAW_BAYER_DEMOSAIC_VALUE}"

    # Colorspace
    dcraw_options+=" -o ${DCRAW_COLORSPACE_VALUE}"

    # 16 bit linearity, same as "-6 -W -g 1 1"
    dcraw_options+=" -4"

    # TIFF output
    dcraw_options+=" -T"

    ### This is tooo noisy....
    # if [ "${verbous_mode}" -gt 0 ]; then
    #   dcraw_options="-v ${dcraw_options}"
    #fi




    # ---------------------------------------
    #  Build mogrify's options string.
    # ---------------------------------------
    local mogrify_options=""


    # Flip or flop the image, if required.
    if [ ! -z "${flipflop_positive}" ]; then
        if [ "${flipflop_positive}" = "flipflop" ]; then
            mogrify_options+=" -flip -flop"
        else
            mogrify_options+=" -${flipflop_positive}"
        fi
    fi


    # Resize image on its larger side
    if [ $resize_width -gt 0 ]; then
        mogrify_options+=" -resize ${resize_width}x${resize_width}>"
    fi


    #  Desaturate colors, if required:
    #  Convert to Grayscale with Gray profile embedded with gamma 1.0
    #  See http://www.graphicsmagick.org/GraphicsMagick.html#details-modulate
    if [ $desaturate_colors -eq 1 ]; then
        # Linear Gamma 1.0 Gray profile
        ICC_PROFILE_PATH=$(color-profiles gray-linear )
        mogrify_options+=" -modulate 100,0 -colorspace Gray"
    fi
    mogrify_options+=" -profile ${ICC_PROFILE_PATH}"


    #  Compress image
    mogrify_options+=" -compress Zip "


    # ---------------------------------------
    # Create output directory if needed.
    # ---------------------------------------
    [ ! -z "${output_directory}" ] && mkdir -p "${output_directory[*]}"


    # =============================================================
    #  The Loop: Process each file given
    # =============================================================

    for RAW_PHOTO in "${INPUT_FILES[@]}"
    do

        # ---------------------------------------
        # Just in case $RAW_PHOTO is NOT a regular file
        # ---------------------------------------
        if [ ! -f "${RAW_PHOTO}" ]; then
            e_warning "$(printf '%s is not a regular file. Ignoring.' "${RAW_PHOTO}")"
            continue;
        fi

        # ---------------------------------------
        # Show some image info
        # ---------------------------------------
        e_info "$(dcraw -i "${RAW_PHOTO}")"
        if [ $verbous_mode -gt 0 ]; then
          e_verbous "$(dcraw -i -v "${RAW_PHOTO}")"
          echo;
        fi

        # ---------------------------------------
        # Filename magic
        # ---------------------------------------
        local input_file_extension="${RAW_PHOTO##*.}";
        local input_file_basename="${RAW_PHOTO%.$input_file_extension}"
        input_file_basename="${input_file_basename##*/}" # remove trailing slash

        # Build output filename as dcraw would do
        local output_tiff="${input_file_basename}.${DCRAW_DEFAULT_TIFF_EXTENSION}"


        # ---------------------------------------
        # Call dcraw
        # ---------------------------------------
        printf "Linear TIFF "
        e_debug "$(printf "\ndcraw %s %s " "${dcraw_options}" "${RAW_PHOTO}")"
        IFS="${DEFAULT_IFS}"
        dcraw ${dcraw_options} "${RAW_PHOTO}" || {
          e_warning "$(printf "Could not create linear tiff: %s" "${RAW_PHOTO}")"
          continue
        }
        IFS="${SAFER_IFS}"

        e_success ""


        # ---------------------------------------
        # Just in case dcraw has NOT written an output file:
        # ---------------------------------------
        if [ ! -f "${output_tiff}" ]; then
            e_warning "$(printf "Hmmm. Expected dcraw to have written '%s'; In fact, this file does not exist?\n" "${output_tiff}")"
            continue
        fi


        # ---------------------------------------
        #  Handle output file
        # ---------------------------------------
        printf "Mangle output file "
        e_debug "$(printf "\nmogrify %s " "${mogrify_options}")"

        IFS="${DEFAULT_IFS}"
        (mogrify ${mogrify_options} "${output_tiff}") || {
            e_warning "$(printf "Hmmm. Mogrifying failed somehow on %s\n" "${output_tiff}")"
            continue
        }
        IFS="${SAFER_IFS}"
        e_success ""

        # Prepare result output
        local result_file="${output_tiff}"


        # ---------------------------------------
        # Move output file to directory, if required
        # ---------------------------------------
        if [ ! -z "${output_directory}" ]; then
            mv "${output_tiff}" "${output_directory}/"
            result_file="${output_directory}/${output_tiff}"
        fi


        # ---------------------------------------
        # Print result
        # ---------------------------------------
        printf "Result %s" "$(e_result "${result_file}")"

    done
}





# ======================================
#  The main procedure
# ======================================

function main {

    # ---------------------------------------
    # Print short help if no arguments
    # ---------------------------------------
    if [ "$#" -eq 0 ]; then
        printf "Run '%s --help' or with '-h' to get a list of all options.\n" "${SCRIPT_NAME}"
        exit 1
    fi



    # ---------------------------------------
    # Normalize options
    #
    # This section is stolen from William Melody's bash-boilerplate
    # <https://github.com/alphabetum/bash-boilerplate>
    # ---------------------------------------

    # iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
    # also turns -- into --endopts to avoid issues with things like '-o-', the '-'
    # should not indicate the end of options, but be an invalid option (or the
    # argument to the option, such as wget -qO-)
    unset options
    # while the number of arguments is greater than 0
    while ((${#}))
    do
      case ${1} in
        # if option is of type -ab
        -[!-]?*)
          # loop over each character starting with the second
          for ((i=1; i<${#1}; i++))
          do
            # extract 1 character from position 'i'
            c=${1:i:1}
            # add current char to options
            options+=("-${c}")

            # if option takes a required argument, and it's not the last char
            # make the rest of the string its argument
            if [[ ${OPTIONS_LIST} = *"${c}:"* && ${1:i+1} ]]
            then
              options+=("${1:i+1}")
              break
            fi
          done
          ;;
        # if option is of type --foo=bar, split on first '='
        --?*=*)
          options+=("${1%%=*}" "${1#*=}")
          ;;
        # end of options, stop breaking them up
        --)
          options+=(--endopts)
          shift
          options+=("${@}")
          break
          ;;
        # otherwise, nothing special
        *)
          options+=("${1}")
          ;;
      esac

      shift
    done
    # set new positional parameters to altered options. Set default to blank.
    set -- "${options[@]:-}"
    unset options


    # ---------------------------------------
    # Parse Options
    # ---------------------------------------

    # Initialize program option variables.
    declare -i use_batch_mode=0
    declare -i print_help=0

    # Keeps all CLI arguments without -a or --all.
    # Used by runBatchMode when letting GNU Parallel
    # call this very script.
    local recursion_arguments=""

    # Keeps anything that does not look like an option.
    local image_parameters=""

    # Keeps anything that does not look like an option.
    local -a image_parameters_array

    # getopts and getopts have inconsistent behavior, so using a simple home-brewed
    # while loop. This isn't perfectly compliant with POSIX, but it's close enough
    # and this appears to be a widely used approach.
    #
    # More info:
    #   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
    #   http://stackoverflow.com/a/14203146
    #   http://stackoverflow.com/a/7948533
    #
    # This section is stolen from William Melody's bash-boilerplate
    # <https://github.com/alphabetum/bash-boilerplate>
    while [ ${#} -gt 0 ]
    do
        __option="${1:-}"
        __maybe_param="${2:-}"

        case "${__option}" in
            -h|--help)
                print_help=1
                ;;
            -a|--all)
                use_batch_mode=1
                ;;
            -d|--desaturate)
                desaturate_colors=1
                recursion_arguments+=" ${__option}"
                ;;
            --debug)
                debug_mode=1
                recursion_arguments+=" ${__option}"
                ;;
            -v|--verbous)
                verbous_mode=1
                recursion_arguments+=" ${__option}"
                ;;
            -f|--flipflop)
                _require_argument "${__option}" "${__maybe_param}"
                flipflop_positive="${__maybe_param}"
                recursion_arguments+=" ${__option} ${__maybe_param}"
                shift
                ;;
            -o|--output)
                _require_argument "${__option}" "${__maybe_param}"
                output_directory="${__maybe_param}"
                recursion_arguments+=" ${__option} \"${__maybe_param}\""
                shift
                ;;
            -r|--resize)
                _require_argument "${__option}" "${__maybe_param}"
                resize_width=${__maybe_param}
                recursion_arguments+=" ${__option} ${__maybe_param}"
                shift
                ;;
            --endopts)
                # Terminate option parsing.
                break
                ;;
            -*)
                # Assume option because of leading "-"
                e_error "$(printf "Unexpected option: %s\n" "${__option}")"
                ;;
            *)
                # "Anything else must be an image parameter"
                # This is a WORKAROUND, as without this "*)" block any given image parameters
                # after the arguments seem to get lost (i.e., stuck in last $__option checked).
                image_parameters_array+=(${__option})
                ;;
        esac
        shift

    done



    # ---------------------------------------
    # Kind of main controller:
    # ---------------------------------------

    if [ $print_help -gt 0 ]; then
        displayHelp
    fi;

    if [ $use_batch_mode -gt 0 ]; then
        runBatchMode ${recursion_arguments}
    else
        convertRawPhotos ${image_parameters_array[@]}
    fi;

}
main "${@}"
